## 1. TCP/IP协议分为几层

> 归类: 网络/协议

<details>
<summary>查看解析</summary>
![](https://uploadfiles.nowcoder.com/images/20190925/320259883_1569384380407_67FEAF11EC1344501BA0194741AF7E49)
</details>

## 2. JSONP的原理是什么

> 归类: 

<details>
<summary>查看解析</summary>
浏览器有同源策略，但是script标签的src属性不会被同源策略所约束，可以获取任意服务器上的脚本并且执行

> jsonp通过插入script标签的方式来实现跨域，参数只能通过url传入，仅可以支持get请求

步骤

* 创建callback方法
* 插入script标签
* 后台接受到请求，解析前端传过去的callback方法，返回该方法的调用，并且数据作为参数传入该方法
* 前台执行服务端返回的方法调用

</details>

## 3. http状态码 301， 302， 304， 403

> 归类: 网络/http

<details>
<summary>查看解析</summary>

> 2xx

这个系列的状态码都表示请求被正常处理了

> 200 OK

表示客户端发来的请求被正常处理了，这种情况一般是最“好”的结果

> 204 No Content

表示服务器已成功处理请求，但是没有任何实体返回，页面不更新。一般用于客户端单方向向服务器发送信息

> 206 Partical Content
表示客户端进行了[范围请求](#rangeRequest),而服务器成功执行了这个请求

> 3xx重定向

这个系列表示浏览器需要执行某些特殊的处理以正常处理请求

> 301 Moved Permantly

永久性重定向，表示请求的资源已被分配了新的url，以后使用该资源时应该使用现在给的url（以报文首部的location字段里给出来了）

> 302 Not Found

临时性重定向，希望用户本次能够使用新的url访问

> 303 See Other

基本功能和302一致。但是明确向用户表示需要用GET方法获得资源

> 当301,302,303系列状态码发回时，几乎所有的浏览器都会把post改成GET，并且删除报文内的主体，之后请求会自动再次发送。当然这么做是有违标准的，但大家都会这么做

> 304 Not Modified

表示客户端发送了附带条件的请求，服务器端找到了资源但是并未符合相应的条件

> 307 Temporary Redirect

临时重定向，与302功能相似

> 4xx 客户端错误

该系列错误表示客户端是错误发生所在

> 400 Bad Request

表示请求报文中存在语法错误。当错误发生时，需要修改内容并再次发送请求。

> 401 Unauthorized

表示需要经过验证，若之前已经验证过了，则表示验证失败

> 403 Forbidden

表示请求资源的访问被拒接了，服务器可以不给出理由，如果有理由，则可以在实体的主体部分中看到

> 404 Not Found

服务器上没有请求的资源

> 5xx服务器错误

表示错误出在服务器上

> 500 Internet Server Error

表示服务器在执行请求时发生了错误，也有可能时bug或者临时的故障

> 503 Service Unavilable

表示服务器暂时超负载或者停机维护，无法处理请求

</details>

## 4. 手写XMLHttpRequest

<details>
<summary>查看解析</summary>

```
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function() {
    if(xhr.readyState === 4 && xhr.status === 200) {
        alert(xhr.responseText)
    }
}
xhr.open("GET", "/api", false)
xhr.send(null)
```

其中xhr.readyState是浏览器判断请求过程各个阶段的，xhr.status是http协议中规定的不同结果的返回状态说明（http状态码）

readyState

* 0 -代理被创建，但尚未调用 open() 方法。
* 1 -open() 方法已经被调用。
* 2 -send() 方法已经被调用，并且头部和状态已经可获得。
* 3 -下载中， responseText 属性已经包含部分数据。
* 4 -下载操作已完成

</details>

## 5. 如何实现跨域

<details>
<summary>查看解析</summary>
浏览器中有同源策略，即在一个域下的页面中，无法通过Ajax获取到其他域的接口，url的

* 协议
* 域名
* 端口

不同均可以视作跨域

但是html中的几个标签可以条比同源策略，script标签，img标签和link标签，这三个标签可以加载其他域的资源，不受同源策略限制

因此有如下应用

* img用作打点
* CDN
* JSONP

解决跨域的方法有

* JSONP
* http header（在服务端设置返回的http头），而且这个方法比JSONP方便


```
response.setHeader("Access-Control-Allow-Origin", "http://m.juejin.com/");  // 第二个参数填写允许跨域的域名称，不建议直接写 "*"
response.setHeader("Access-Control-Allow-Headers", "X-Requested-With");
response.setHeader("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS");

// 接收跨域的cookie
response.setHeader("Access-Control-Allow-Credentials", "true");
```

</details>




